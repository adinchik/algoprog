import contest from "../../lib/contest"
import label from "../../lib/label"
import level from "../../lib/level"
import page from "../../lib/page"
import problem from "../../lib/problem"

contest_16067 = () ->
    return contest("2В: Продвинутые задачи на ДП", [
        problem(2998),
        problem(2999),
        problem(210),
        problem(2963),
        problem(3003),
        problem(619),
        problem(1119),
    ])

contest_16065 = () ->
    return contest("2В: *Продвинутые задачи на рекурсивный перебор", [
        problem(157),
        problem(1680),
        problem(2776),
        problem(3879),
        problem(3096),
        problem(158),
        problem(159),
    ])

contest_16068 = () ->
    return contest("2В: Продвинутые задачи на множители", [
        problem(152),
        problem(584),
        problem(1009),
    ])

contest_16066 = () ->
    return contest("2В: Продвинутые задачи на квадратичные сортировки И на стек-очередь-дек", [
        problem(720),
        problem(1137),
        problem(111628),
        problem(51),
        problem(112736),
    ])

contest_16064 = () ->
    return contest("2В: Продвинутые задачи на НОД", [
        problem(1465),
        problem(668),
        problem(1422),
        problem(1346),
        problem(404),
    ])

module16828 = () ->
    page("Разбор задачи \"Резисторы\"", """
        <div class="box generalbox generalboxcontent boxaligncenter clearfix"><h1>Разбор задачи "Резисторы"</h1>
        <p>(В этой задаче все равно — говорить про резисторы или про конденсаторы, т.к. формулы соединения аналогичны, только для резисторов для последовательного соединения формула та же, что для конденсаторов для параллельного, и наоборот. На задачу это не влияет. Я для удобства буду говорить про резисторы, а не про конденсаторы.)</p>
        <p>"Резисторы" — это задача, скажем так, "общего вида" на перебор. А именно, если в других задачах на перебор вы обычно формируете какую-нибудь <i>последовательность</i>, последовательно к текущему решению добавляя что-то еще, то здесь так просто не получится. </p>
        <p>Вы можете попробовать делать так: у вас есть некоторая текущая схема. Вы берете очередной еще не использованный резистор и присоединяете его к текущей схеме или последовательно или параллельно. Потом берете очередной еще не использованный резистор и т.д. Но с таким решением есть проблема: вы не сможете получить по-настоящему сложную схему. Например, рассмотрим следующую схему:</p>
        <pre>         +--D-E-+
         +-A--B--+      +--+
        -+       +--F-G-+  +---
         |                 | 
         +-G--H--+--I--+---+
                 |     |
                 +-J-K-+ 
        </pre>
        <p>(буквы обозначают резисторы)</p>
        <p>Вы ее получить не сможете, т.к. тут надо сначала собрать несколько отдельных схем, а потом уже их объединить в одну.</p>
        <p>Вы можете попробовать собирать сразу две схемы, но все равно вы не сможете полностью покрыть все разнообразие решений.</p>
        <p>Поэтому эту задачу можно решать по-другому. А именно, переформулируем ее так. У нас на столе лежат N резисторов. Мы можем взять два из них, убрать, а вместо них положить резистор, равный или последовательно соединенным этим двум резисторам, или параллельно соединенным. Т.е. любые два резистора мы можем заменить на результат их последовательного или параллельного соединения. После этого мы можем опять взять два любых резистора (в том числе и тот, который только получили из предыдущих двух) и заменить на один. И т.д. Ясно, что вот это как раз покрывает все разнообразие схем, т.к. никто нас не заставляет все время наращивать одну конкретную схему, мы можем сначала собрать несколько кусков, а потом их как надо объединить.</p>
        <p>И это очень легко реализуется. Процедура <code>find</code> будет выбирать два резистора, заменять их на одно, и запускаться рекурсивно.</p>
        <pre>var r:array[...] of extended; // резисторы, которые сейчас лежат на столе
            n:integer; // количество резисторов
        procedure find;
        var i,j:integer;
            r1,r2:extended;
        begin
        for i:=1 to n do
            for j:=i+1 to n do begin
                r1:=r[i];
                r2:=r[j];
                // начинается магия, поймите ее!
                r[j]:=r[n];
                dec(n);
                r[i]:=r1+r2;
                find;
                r[i]:=r1*r2/(r1+r2);
                find;
                inc(n);
                r[n]:=r[j];
                r[i]:=r1;
                r[j]:=r2;
            end;
        end;
        </pre>
        <p>Вот и все. Даже не надо проверки на выход из рекурсии, т.к. когда станет <code>n=1</code>, то циклы не выполнятся ни разу. Осталось только проверять все получающиеся резисторы на предмет того, не получается ли хорошее решение, это проще всего сделать циклом по всем имеющимся резисторам в начале процедуры find.</p>
        
        <p>Что тут важно. Что тут решение строится не путем последовательных добавлений, а что вы честно исследуете все возможные пути. Можете думать об этом как о некоторой игре, в которой есть позиции (какие резисторы на столе) и возможные ходы из каждой позиции, и вы просто перебираете такие ходы.</p></div>
    """, {skipTree: true})

contest_16070 = () ->
    return contest("2В: Дополнительные задачи на разные темы - 2", [
        problem(422),
        problem(492),
        problem(111702),
        problem(1441),
        problem(111162),
        problem(1026),
        problem(3183),
        problem(1230),
        problem(3678),
        problem(111751),
    ])

contest_16069 = () ->
    return contest("2В: Дополнительные задачи на разные темы", [
        problem(1037),
        problem(52),
        problem(1129),
        problem(1758),
        problem(1630),
        problem(637),
        problem(111648),
    ])

export default level_2C = () ->
    return level("2В", [
        label("<p>Чтобы перейти на следующий уровень, надо решить <b>минимум половину задач</b> (не учитывая продвинутых задач на рекурсивный перебор). Когда вы их решите, я рекомендую вам переходить на следующий уровень, чтобы не откладывать изучение новой теории. К оставшимся задачам этого уровня возвращайтесь позже время от времени и постарайтесь со временем все-таки дорешать почти все их до конца.</p>"),
        contest_16064(),
        contest_16065(),
        module16828(),
        contest_16066(),
        contest_16067(),
        contest_16068(),
        contest_16069(),
        contest_16070(),
    ])